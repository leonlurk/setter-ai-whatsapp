const path = require('path');
const fs = require('fs');
const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js'); // Usar LocalAuth para sesiones persistentes
const qrcode = require('qrcode-terminal');
const { GoogleGenerativeAI } = require('@google/generative-ai');
require('dotenv').config(); // Cargar variables de entorno (ej. GEMINI_API_KEY)
const { loadData, saveData } = require('./utils'); // Importar desde utils.js
const admin = require('firebase-admin'); 

// --- Obtener User ID --- 
const userId = process.argv[2]; 
if (!userId) {
    console.error('[Worker] ERROR: No se proporcion√≥ userId al iniciar el worker.');
    process.exit(1); // Salir si no hay ID de usuario
}
console.log(`[Worker ${userId}] Iniciando worker...`);

// --- Obtener Active Agent ID (pasado como 3er argumento) ---
let currentAgentId = process.argv[3] || null;
console.log(`[Worker ${userId}] Active Agent ID inicial: ${currentAgentId || 'Ninguno (usar√° default)'}`);

// --- Definici√≥n de Rutas y Archivos --- 
const USER_DATA_PATH = path.join(__dirname, 'data_v2', userId);
const SESSION_PATH = path.join(USER_DATA_PATH, '.wwebjs_auth'); // Directorio para la sesi√≥n de WhatsApp
const AGENT_CONFIG_FILE = path.join(USER_DATA_PATH, 'agent_config.json');
const RULES_FILE = path.join(USER_DATA_PATH, 'rules.json');
const GEMINI_STARTERS_FILE = path.join(USER_DATA_PATH, 'gemini-starters.json');
const UPLOADS_DIR = path.join(USER_DATA_PATH, 'uploads'); // Directorio de uploads por usuario
const ACTION_FLOWS_FILE = path.join(__dirname, 'action_flows.json'); // Ruta al archivo global de flujos

// Crear directorios espec√≠ficos del usuario si no existen
if (!fs.existsSync(USER_DATA_PATH)) fs.mkdirSync(USER_DATA_PATH, { recursive: true });
if (!fs.existsSync(SESSION_PATH)) fs.mkdirSync(SESSION_PATH, { recursive: true });
if (!fs.existsSync(UPLOADS_DIR)) fs.mkdirSync(UPLOADS_DIR, { recursive: true });

// --- Carga Inicial de Configuraci√≥n --- 
console.log(`[Worker ${userId}] Preparando configuraci√≥n inicial (esperando datos via IPC)...`);

// Configuraci√≥n por defecto para el agente
const DEFAULT_AGENT_CONFIG = {
    persona: { name: "Agente IA (Default)", role: "Asistente", language: "es", tone: "Neutral", style: "Directo", guidelines: [] }, 
    knowledge: { files: [], urls: [], qandas: [] } 
};

// Variable para almacenar la configuraci√≥n del agente ACTIVO
let agentConfig = { ...DEFAULT_AGENT_CONFIG }; // Iniciar con el default

// Variables para almacenar reglas y flujos
let autoReplyRules = []; // Reglas simples de respuesta autom√°tica
let geminiConversationStarters = []; // Starters de conversaci√≥n con Gemini
let actionFlows = []; // Flujos de acci√≥n

// <<< ADDED: Firestore Initialization for Worker >>>
let firestoreDbWorker;
try {
    // Re-initialize using the same credentials as the master process expects
    const serviceAccountPath = process.env.GOOGLE_APPLICATION_CREDENTIALS;
    if (!serviceAccountPath || !fs.existsSync(serviceAccountPath)) {
        throw new Error(`Service account key not found at: ${serviceAccountPath}`);
    }
    // Check if Firebase app is already initialized (less likely in separate process, but good practice)
    if (admin.apps.length === 0) {
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccountPath)
        });
         console.log(`[Worker ${userId}] Firebase Admin SDK initialized in worker.`);
    } else {
         console.log(`[Worker ${userId}] Firebase Admin SDK already initialized.`);
    }
    firestoreDbWorker = admin.firestore();
} catch (error) {
    console.error(`[Worker ${userId}][ERROR CR√çTICO] Initializing Firebase Admin SDK in worker:`, error);
    // Notify master?
    sendErrorInfo(`Critical Firebase Init Error: ${error.message}`);
    // Exit? If Firestore is essential for state, the worker might be useless without it.
    process.exit(1);
}
// <<< END: Firestore Initialization for Worker >>>

// <<< ADDED: Gemini Initialization with try...catch >>>
try {
    const geminiApiKey = process.env.GEMINI_API_KEY;
    if (!geminiApiKey) {
      throw new Error("GEMINI_API_KEY environment variable is not defined.");
    }
    const genAI = new GoogleGenerativeAI(geminiApiKey);
    geminiModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash"});
    console.log(`[Worker ${userId}] Gemini Model initialized successfully. Type: ${typeof geminiModel}`); // Log success and type
} catch(geminiInitError) {
    console.error(`[Worker ${userId}][ERROR CR√çTICO] Initializing GoogleGenerativeAI:`, geminiInitError);
    sendErrorInfo(`Critical Gemini Init Error: ${geminiInitError.message}`);
    // Exit? If Gemini is essential, the worker might be useless without it.
    process.exit(1);
}
// <<< END: Gemini Initialization >>>

// <<< ADDED: Sistema de rate limiting para Gemini >>>
// Variables para el rate limiting
let geminiRequestsInLastMinute = 0;
let geminiRequestsTimestamps = [];
const MAX_GEMINI_REQUESTS_PER_MINUTE = 30; // Ajustar seg√∫n l√≠mites de tu API
const REQUEST_TRACKING_WINDOW_MS = 60000; // 1 minuto en milisegundos

// Funci√≥n para verificar y gestionar rate limiting
function checkGeminiRateLimit() {
    const now = Date.now();
    
    // Eliminar timestamps antiguos (mayores a 1 minuto)
    geminiRequestsTimestamps = geminiRequestsTimestamps.filter(timestamp => 
        now - timestamp < REQUEST_TRACKING_WINDOW_MS
    );
    
    // Verificar cu√°ntas solicitudes hemos hecho en el √∫ltimo minuto
    geminiRequestsInLastMinute = geminiRequestsTimestamps.length;
    
    // Si estamos cerca del l√≠mite, esperar
    if (geminiRequestsInLastMinute >= MAX_GEMINI_REQUESTS_PER_MINUTE) {
        const oldestRequest = geminiRequestsTimestamps[0];
        const timeToWaitMs = REQUEST_TRACKING_WINDOW_MS - (now - oldestRequest) + 100; // +100ms de margen
        
        console.warn(`[Worker ${userId}][RATE LIMIT] L√≠mite de solicitudes Gemini alcanzado (${geminiRequestsInLastMinute}/${MAX_GEMINI_REQUESTS_PER_MINUTE}). Esperando ${timeToWaitMs}ms...`);
        return timeToWaitMs;
    }
    
    // Si no hay problema, registrar la nueva solicitud
    geminiRequestsTimestamps.push(now);
    return 0; // No es necesario esperar
}

// <<< ADDED: Respuestas de fallback para cuando Gemini no est√° disponible >>>
const FALLBACK_RESPONSES = [
    "Lo siento, en este momento estoy experimentando una alta demanda. ¬øPodr√≠as intentar de nuevo en unos minutos?",
    "Disculpa la interrupci√≥n. Estoy procesando muchas consultas en este momento. Por favor, int√©ntalo de nuevo m√°s tarde.",
    "Parece que hay mucho tr√°fico en el sistema. Intentar√© responder tu mensaje m√°s tarde cuando haya menos carga.",
    "Estoy teniendo dificultades para procesar tu solicitud en este momento debido a limitaciones temporales de recursos. Te atender√© en cuanto pueda."
];

// Funci√≥n para obtener una respuesta de fallback aleatoria
function getFallbackResponse() {
    const randomIndex = Math.floor(Math.random() * FALLBACK_RESPONSES.length);
    return FALLBACK_RESPONSES[randomIndex];
}

// Actualizar callGeminiWithRetry para usar respuestas de fallback cuando sea necesario
async function callGeminiWithRetry(prompt, maxRetries = 3, initialBackoffMs = 1000) {
    let retryCount = 0;
    let backoffMs = initialBackoffMs;

    // Verificar rate limiting antes de hacer la solicitud
    const waitTimeMs = checkGeminiRateLimit();
    if (waitTimeMs > 0) {
        console.log(`[Worker ${userId}][Gemini] Esperando ${waitTimeMs}ms por rate limiting...`);
        await new Promise(resolve => setTimeout(resolve, waitTimeMs));
    }

    while (retryCount <= maxRetries) {
        try {
            console.log(`[Worker ${userId}][Gemini] Intento ${retryCount + 1}/${maxRetries + 1} para generar contenido`);
            const result = await geminiModel.generateContent(prompt);
            return await result.response.text();
        } catch (error) {
            console.error(`[Worker ${userId}][Gemini] Error en intento ${retryCount + 1}:`, error);
            
            // Verificar si es un error de cuota (429)
            if (error.status === 429) {
                const retryDelay = error.errorDetails?.find(detail => 
                    detail['@type'] === 'type.googleapis.com/google.rpc.RetryInfo'
                )?.retryDelay;
                
                // Extraer segundos del retryDelay si est√° presente ('24s' -> 24000)
                let waitTime = backoffMs;
                if (retryDelay) {
                    const seconds = parseInt(retryDelay.replace('s', ''));
                    if (!isNaN(seconds)) {
                        waitTime = seconds * 1000;
                        console.log(`[Worker ${userId}][Gemini] Google recomienda esperar ${seconds}s antes de reintentar`);
                    }
                }
                
                // Aumentar backoff para el pr√≥ximo intento
                backoffMs = backoffMs * 2;
                
                if (retryCount < maxRetries) {
                    console.log(`[Worker ${userId}][Gemini] Error de cuota (429). Esperando ${waitTime/1000}s antes de reintentar...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    retryCount++;
                    continue;
                }
            }
            
            // Si no es un error de cuota o se acabaron los intentos, propagar el error
            if (retryCount >= maxRetries) {
                console.error(`[Worker ${userId}][Gemini] Se agotaron los reintentos (${maxRetries + 1}). Error: ${error.message}`);
                // En lugar de propagar el error, devolver una respuesta de fallback
                console.log(`[Worker ${userId}][Gemini] Utilizando respuesta de fallback`);
                return getFallbackResponse();
            }
            
            // Para otros errores, implementar backoff exponencial
            if (retryCount < maxRetries) {
                console.log(`[Worker ${userId}][Gemini] Reintentando en ${backoffMs/1000}s...`);
                await new Promise(resolve => setTimeout(resolve, backoffMs));
                backoffMs = backoffMs * 2; // Backoff exponencial
                retryCount++;
            } else {
                // En lugar de propagar el error, devolver una respuesta de fallback
                console.log(`[Worker ${userId}][Gemini] Utilizando respuesta de fallback por error general`);
                return getFallbackResponse();
            }
        }
    }
}
// <<< END: Sistema de rate limiting para Gemini >>>

// Funci√≥n para enviar estado/error al proceso Master
function sendStatusUpdate(status, error = null) {
    if (process.send) {
        process.send({ type: 'STATUS_UPDATE', status, error });
    } else {
        console.warn(`[Worker ${userId}] Imposible enviar STATUS_UPDATE (process.send no disponible)`);
    }
}

// Funci√≥n para enviar QR al proceso Master
function sendQrCode(qr) {
    if (process.send) {
        process.send({ type: 'QR_CODE', qr });
    } else {
         console.warn(`[Worker ${userId}] Imposible enviar QR_CODE (process.send no disponible)`);
    }
}

// Funci√≥n para enviar un error espec√≠fico al Master
function sendErrorInfo(errorMsg) {
     if (process.send) {
        process.send({ type: 'ERROR_INFO', error: errorMsg });
    } else {
        console.error(`[Worker ${userId}] ERROR: ${errorMsg} (process.send no disponible)`);
    }
}

// --- Funci√≥n auxiliar para resolver variables en strings ---
function resolveVariables(templateString, context) {
    if (!templateString || typeof templateString !== 'string') {
        return templateString; // Devuelve el original si no es un string v√°lido
    }
    // Regex para encontrar {{path.to.variable}}
    return templateString.replace(/\{\{([^}]+)\}\}/g, (match, path) => {
        try {
            const keys = path.trim().split('.');
            let value = context;
            for (const key of keys) {
                if (value === undefined || value === null) {
                    // console.warn(`[resolveVariables] Path intermedio ${key} no encontrado en contexto para ${path}`);
                    return match; // No reemplazar si el path es inv√°lido
                }
                value = value[key];
            }
            return typeof value === 'object' ? JSON.stringify(value) : (value ?? match);
        } catch (error) {
            console.error(`[resolveVariables] Error resolviendo path "${path}":`, error);
            return match;
        }
    });
}

// --- Funci√≥n auxiliar para evaluar condiciones ---
function evaluateCondition(conditionObj, context) {
    if (!conditionObj || typeof conditionObj !== 'object' || !conditionObj.variable || !conditionObj.operator) {
        console.warn('[evaluateCondition] Condici√≥n inv√°lida: falta variable u operador.');
        return false;
    }

    const { variable, operator, value: compareValue } = conditionObj;
    let actualValue = null;

    try {
        const keys = variable.trim().split('.');
        let current = context;
        for (const key of keys) {
            if (current === undefined || current === null) throw new Error(`Path intermedio ${key} no encontrado.`);
            current = current[key];
        }
        actualValue = current;
    } catch (error) {
        // console.warn(`[evaluateCondition] No se pudo obtener valor para variable "${variable}": ${error.message}`);
        actualValue = null;
    }

    const actualValueStr = actualValue === null || actualValue === undefined ? '' : String(actualValue);
    const compareValueStr = compareValue === null || compareValue === undefined ? '' : String(compareValue);

    // console.log(`[evaluateCondition] Evaluando: "${actualValueStr}" ${operator} "${compareValueStr}"`);

    switch (operator.toLowerCase()) {
        case 'equals':
            return actualValueStr === compareValueStr;
        case 'contains':
            return actualValueStr.includes(compareValueStr);
        case 'starts_with':
            return actualValueStr.startsWith(compareValueStr);
        case 'is_empty':
            return actualValue === null || actualValue === undefined || actualValueStr === '';
        default:
            console.warn(`[evaluateCondition] Operador desconocido: ${operator}`);
            return false;
    }
}

// --- Funci√≥n auxiliar para a√±adir un retraso aleatorio ---
function randomDelay(minMs = 2500, maxMs = 3500) {
  const delayTime = Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
  console.log(`   -> [Delay] Esperando ${delayTime}ms antes de enviar...`);
  return new Promise(resolve => setTimeout(resolve, delayTime));
}

// --- Funci√≥n REFACTORIZADA para ejecutar una lista de pasos ---
async function executeSteps(stepsToExecute, context) {
    const userId = context.message.from; // Usar sender para logs

    for (const step of stepsToExecute) {
        // console.log(`[Worker ${userId}][Flow Engine] Procesando paso tipo: ${step.type}`); // Log detallado
        switch (step.type) {
            case 'send_message':
                if (step.content) {
                    const resolvedContent = resolveVariables(step.content, context);
                    try {
                         // <<< MODIFICADO: Usar nueva funci√≥n de presencia >>>
                         const originalSender = context.message?.from; 
                         if (originalSender) { // Asegurarse de que tenemos un sender
                            const userIsActiveFlow = await isUserActiveInChat(userId, originalSender);
                            if (userIsActiveFlow) {
                                console.log(`[Worker ${userId}][Presence DB][Flow] User is active in chat ${originalSender}. Skipping send_message step.`);
                                break; // Sale del switch para este paso, contin√∫a con el siguiente del flujo
                            }
                         } else {
                             console.warn(`[Worker ${userId}][Flow Engine] No se pudo determinar el remitente original en el contexto para el chequeo de presencia.`);
                             // ¬øContinuar o detener? Por ahora continuamos.
                         }
                         // <<< FIN MODIFICACI√ìN >>>

                         console.log(`   -> INTENTANDO enviar mensaje: "${resolvedContent}"`); 
                         await randomDelay(); // <<< A√ëADIDO DELAY
                         await client.sendMessage(context.message.from, resolvedContent);
                         
                         // Guardar el mensaje autom√°tico en Firestore con isAutoReply=true
                         try {
                             const chatDocRef = firestoreDbWorker.collection('users').doc(userId)
                                 .collection('chats').doc(context.message.from);
                             const messagesColRef = chatDocRef.collection('messages');
                             
                             await messagesColRef.add({
                                 from: `me (Flow - ${userId})`,
                                 to: context.message.from,
                                 body: resolvedContent,
                                 timestamp: admin.firestore.FieldValue.serverTimestamp(),
                                 isFromMe: true,
                                 isAutoReply: true
                             });
                             
                             console.log(`[Worker ${userId}][Flow Engine] Mensaje autom√°tico guardado en Firestore con isAutoReply=true`);
                         } catch (dbError) {
                             console.error(`[Worker ${userId}][Flow Engine] Error guardando mensaje autom√°tico en Firestore:`, dbError);
                         }
                         // Log original (despu√©s) lo dejamos comentado o lo quitamos si preferimos
                         // console.log(`   -> Mensaje enviado: "${resolvedContent}"`);
                    } catch (sendError) {
                         console.error(`[Worker ${userId}][Flow Engine] Error enviando mensaje en paso:`, sendError);
                         sendErrorInfo(`Error enviando mensaje de flujo: ${sendError.message}`);
                    }
                } else {
                    console.warn(`   -> Paso send_message sin 'content'. Saltando.`);
                }
                break;
            
            case 'run_gemini':
                if (step.prompt && typeof step.prompt === 'string') {
                    const resolvedPrompt = resolveVariables(step.prompt, context);
                    // console.log(`   -> Ejecutando Gemini con prompt resuelto: "${resolvedPrompt.substring(0, 50)}..."`);
                    try {
                        const result = await callGeminiWithRetry(resolvedPrompt);
                        const geminiResponseText = await result;
                        
                        if (geminiResponseText) {
                            // console.log(`   -> Respuesta Gemini generada.`);
                            if (step.outputVariable && typeof step.outputVariable === 'string' && step.outputVariable.trim()) {
                                const varName = step.outputVariable.trim();
                                context.variables[varName] = geminiResponseText;
                                // console.log(`      -> Respuesta guardada en context.variables.${varName}`);
                            } else {
                                // console.log(`      -> No se especific√≥ outputVariable. Enviando respuesta directamente.`);
                                try {
                                    await randomDelay(); // <<< A√ëADIDO DELAY
                                    await client.sendMessage(context.message.from, geminiResponseText);
                                    // console.log(`         -> Respuesta Gemini enviada a ${context.message.from}.`);
                                } catch (sendError) {
                                      console.error(`[Worker ${userId}][Flow Engine] Error enviando respuesta Gemini:`, sendError);
                                      sendErrorInfo(`Error enviando resp Gemini: ${sendError.message}`);
                                }
                            }
                            // await new Promise(resolve => setTimeout(resolve, 300)); // Delay menor eliminado
                        } else {
                            console.warn(`   -> Gemini no gener√≥ respuesta para el prompt.`);
                            if (step.outputVariable && typeof step.outputVariable === 'string' && step.outputVariable.trim()) {
                                context.variables[step.outputVariable.trim()] = null;
                            }
                        }
                    } catch (geminiError) {
                       console.error(`   -> [Error Gemini] Error ejecutando el paso run_gemini:`, geminiError);
                       sendErrorInfo(`Error en paso run_gemini: ${geminiError.message}`);
                       if (step.outputVariable && typeof step.outputVariable === 'string' && step.outputVariable.trim()) {
                            context.variables[step.outputVariable.trim()] = null;
                       }
                    }
                } else {
                    console.warn(`   -> Paso run_gemini sin 'prompt' v√°lido. Saltando.`);
                }
                break;
            
            case 'condition':
                if (step.if && step.then && Array.isArray(step.then)) {
                    // console.log(`   -> Evaluando condici√≥n...`);
                    const conditionResult = evaluateCondition(step.if, context);
                    // console.log(`      -> Resultado de la condici√≥n: ${conditionResult}`);

                    if (conditionResult) {
                        // console.log(`   -> Ejecutando bloque 'then'...`);
                        await executeSteps(step.then, context); // Llamada recursiva
                    } else if (step.else && Array.isArray(step.else)) {
                        // console.log(`   -> Ejecutando bloque 'else'...`);
                        await executeSteps(step.else, context); // Llamada recursiva
                    } // else: no hacer nada si es falso y no hay bloque else
                } else {
                    console.warn(`   -> Paso condition mal formado (falta 'if' o 'then'). Saltando.`);
                }
                break;

            default:
                console.warn(`   -> Tipo de paso desconocido: ${step.type}. Saltando.`);
                break;
        }
    }
}

// --- Funci√≥n PRINCIPAL para ejecutar flujos de acci√≥n (refactorizada) ---
async function executeActionFlow(message, flow) {
    const sender = message.from;
    const userId = sender; // Identificador para logs
    console.log(`[Worker ${userId}][Flow Engine] Iniciando flujo: ${flow.name} (ID: ${flow.id})`);

    if (!flow.steps || !Array.isArray(flow.steps) || flow.steps.length === 0) {
        console.error(`[Worker ${userId}][Flow Engine] Error: Flujo ${flow.id} sin pasos v√°lidos.`);
        return;
    }

    const flowContext = {
        message: { from: sender, body: message.body, id: message.id.id },
        variables: {}
    };

    try {
        await executeSteps(flow.steps, flowContext);
        console.log(`[Worker ${userId}][Flow Engine] Flujo ${flow.name} completado.`);

    } catch (error) {
        console.error(`[Worker ${userId}][Flow Engine] Error GRAL ejecutando flujo ${flow.name}:`, error);
        sendErrorInfo(`Error ejecutando flujo ${flow.id}: ${error.message}`);
    }
}

// --- Listeners de Eventos del Cliente WhatsApp ---
const client = new Client({
    authStrategy: new LocalAuth({ clientId: userId, dataPath: SESSION_PATH }), // Usa LocalAuth con ruta espec√≠fica
    puppeteer: {
        args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage', '--disable-gpu'], // A√±adir disable-gpu
        headless: true
    }
});

// A√ëADIR FUNCI√ìN DE DIAGN√ìSTICO DE PUPPETEER
async function diagnosePuppeteerEnvironment() {
    console.log(`[Worker ${userId}][DIAGN√ìSTICO] Verificando entorno para Puppeteer...`);
    try {
        // Verificar requisitos del sistema
        const chromiumPath = require('puppeteer').executablePath();
        console.log(`[Worker ${userId}][DIAGN√ìSTICO] Ruta ejecutable Chromium: ${chromiumPath}`);
        
        // Verificar si la ruta existe
        if (fs.existsSync(chromiumPath)) {
            console.log(`[Worker ${userId}][DIAGN√ìSTICO] ‚úÖ Ejecutable Chromium encontrado`);
        } else {
            console.error(`[Worker ${userId}][DIAGN√ìSTICO] ‚ùå Ejecutable Chromium NO ENCONTRADO en la ruta`);
        }
        
        // Verificar permisos y espacio en disco
        try {
            const stats = fs.statSync(chromiumPath);
            console.log(`[Worker ${userId}][DIAGN√ìSTICO] Permisos Chromium: ${stats.mode}, Tama√±o: ${stats.size} bytes`);
        } catch (statErr) {
            console.error(`[Worker ${userId}][DIAGN√ìSTICO] ‚ùå Error verificando permisos: ${statErr.message}`);
        }
        
        // Verificar dependencias
        try {
            const { execSync } = require('child_process');
            const libsCheck = execSync('ldd $(which chromium-browser) | grep "not found" || echo "All dependencies OK"').toString();
            console.log(`[Worker ${userId}][DIAGN√ìSTICO] Verificaci√≥n dependencias:\n${libsCheck}`);
        } catch (libErr) {
            console.error(`[Worker ${userId}][DIAGN√ìSTICO] ‚ùå Error verificando dependencias: ${libErr.message}`);
        }
        
        // Verificar memoria disponible
        try {
            const { execSync } = require('child_process');
            const memInfo = execSync('free -m').toString();
            console.log(`[Worker ${userId}][DIAGN√ìSTICO] Informaci√≥n de memoria:\n${memInfo}`);
        } catch (memErr) {
            console.error(`[Worker ${userId}][DIAGN√ìSTICO] ‚ùå Error verificando memoria: ${memErr.message}`);
        }
        
        console.log(`[Worker ${userId}][DIAGN√ìSTICO] Verificaci√≥n de entorno completada`);
    } catch (error) {
        console.error(`[Worker ${userId}][DIAGN√ìSTICO] ‚ùå Error general: ${error.message}`);
    }
}

// Ejecutar diagn√≥stico antes de inicializar
diagnosePuppeteerEnvironment()
    .then(() => {
        console.log(`[Worker ${userId}][CRITICAL] ANTES de client.initialize(). Client tipo: ${typeof client}, isValid: ${!!client}`);
        try {
            client.initialize()
                .then(() => {
                    console.log(`[Worker ${userId}][CRITICAL] client.initialize() completado con √©xito en el .then()`);
                })
                .catch(initError => {
                    console.error(`[Worker ${userId}][CRITICAL] ERROR en client.initialize().catch():`, initError);
                    sendErrorInfo(`Error en initialize(): ${initError.message}`);
                    // Notificar al servidor sobre el error cr√≠tico
                    sendStatusUpdate('error', `Error de inicializaci√≥n: ${initError.message}`);
                });
            console.log(`[Worker ${userId}][CRITICAL] Llamada a client.initialize() realizada. Esperando eventos...`);
        } catch (outerError) {
            console.error(`[Worker ${userId}][CRITICAL] ERROR EXTERNO al llamar client.initialize():`, outerError);
            sendErrorInfo(`Error externo initialize(): ${outerError.message}`);
            sendStatusUpdate('error', `Error cr√≠tico: ${outerError.message}`);
        }
    })
    .catch(diagErr => {
        console.error(`[Worker ${userId}][CRITICAL] Error en diagn√≥stico previo: ${diagErr.message}`);
        sendErrorInfo(`Error en diagn√≥stico previo: ${diagErr.message}`);
        sendStatusUpdate('error', `Error en diagn√≥stico previo: ${diagErr.message}`);
});

client.on('qr', async (qr) => {
    console.log(`[Worker ${userId}] QR Recibido. Generando Data URL...`);
    sendStatusUpdate('generating_qr'); // Informar al master
    try {
        const qrCodeUrl = await qrcode.generate(qr, { small: true });
        console.log(`[Worker ${userId}] QR Data URL generado.`);
        sendQrCode(qrCodeUrl); // Enviar QR al master
    } catch (err) {
        console.error(`[Worker ${userId}] ERROR generando QR Data URL:`, err);
        sendStatusUpdate('error', 'Error generando QR');
    }
});

// Eventos de depuraci√≥n adicionales de Puppeteer para WhatsApp Web
client.pupBrowser?.on('disconnected', () => {
    console.error(`[Worker ${userId}][CRITICAL] Navegador Puppeteer desconectado inesperadamente`);
    sendStatusUpdate('error', 'Navegador Puppeteer desconectado');
});

client.on('ready', () => {
    console.log(`[Worker ${userId}] Cliente WhatsApp LISTO!`);
    sendStatusUpdate('connected'); // Informar al master
});

client.on('authenticated', () => {
    console.log(`[Worker ${userId}] Cliente AUTENTICADO`);
    // Podr√≠amos enviar un estado intermedio si quisi√©ramos
    // sendStatusUpdate('authenticated'); 
});

client.on('auth_failure', (msg) => {
    console.error(`[Worker ${userId}] FALLO DE AUTENTICACI√ìN: ${msg}`);
    sendStatusUpdate('error', `Fallo de autenticaci√≥n: ${msg}`);
    // Production Consideration: Decide if auth failure is fatal. Often it is.
    // Consider exiting: process.exit(1);
});

client.on('disconnected', (reason) => {
  console.log(`[Worker ${userId}] Cliente DESCONECTADO:`, reason);
  // No in-memory state to clear anymore.
  sendStatusUpdate('disconnected', `Desconectado: ${reason}`);
  // ¬øIntentar reiniciar autom√°ticamente? Por ahora no.
});

client.on('loading_screen', (percent, message) => {
    console.log(`[Worker ${userId}] Cargando: ${percent}% - ${message}`);
    // Podr√≠amos enviar este progreso al Master si quisi√©ramos
});

// Eventos adicionales para diagnosticar problemas de conectividad
client.on('change_state', state => {
    console.log(`[Worker ${userId}][STATE] Estado del cliente cambiado a: ${state}`);
});

client.on('change_battery', batteryInfo => {
    console.log(`[Worker ${userId}][BATTERY] Info bater√≠a actualizada:`, batteryInfo);
});

// Monitorear TODOS los tipos de mensajes
client.on('message_create', async (message) => {
    console.log(`[Worker ${userId}][MESSAGE_CREATE] Mensaje creado. FromMe: ${message.fromMe}, From: ${message.from}, Body: "${message.body?.substring(0, 30)}..."`);
    
    // Solo procesar mensajes salientes (fromMe = true)
    // Los entrantes ya son procesados por el evento 'message'
    if (message.fromMe && !message.id.remote.endsWith('@g.us')) {
        console.log(`[Worker ${userId}][MESSAGE_CREATE] Procesando mensaje SALIENTE para guardar en Firestore`);
        
        // Determinar el ID del destinatario (chatPartnerId) para Firestore
        const chatPartnerId = message.to;
        
        // Referencias de Firestore
        const chatDocRef = firestoreDbWorker.collection('users').doc(userId).collection('chats').doc(chatPartnerId);
        const messagesColRef = chatDocRef.collection('messages');
        
        try {
            console.log(`[Worker ${userId}][FIRESTORE] Guardando mensaje SALIENTE en: users/${userId}/chats/${chatPartnerId}/messages`);
            const messageData = {
                body: message.body,
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                isFromMe: true,
                isAutoReply: null, // Expl√≠citamente null para diferenciar de los mensajes autom√°ticos
                IS_GENUINE_USER: true, // NUEVO: flag muy expl√≠cito para mensajes reales del usuario
                messageId: message.id.id,
                from: `me (User REAL - ${userId})`, // Modificado para ser muy expl√≠cito
                to: chatPartnerId
            };
            console.log(`[Worker ${userId}][FIRESTORE] Datos a guardar (mensaje saliente):`, JSON.stringify(messageData));
            
            // Guardar el mensaje y obtener referencia
            const messageRef = await messagesColRef.add(messageData);
            console.log(`[Worker ${userId}][FIRESTORE] Mensaje SALIENTE guardado con ID: ${messageRef.id}`);
            
            // Verificar que se guard√≥ correctamente
            const savedMessage = await messageRef.get();
            if (savedMessage.exists) {
                console.log(`[Worker ${userId}][FIRESTORE] ‚úÖ Verificaci√≥n: Mensaje SALIENTE guardado correctamente`);
            } else {
                console.error(`[Worker ${userId}][FIRESTORE] ‚ùå ERROR DE VERIFICACI√ìN: El mensaje SALIENTE no se guard√≥ correctamente`);
            }
            
            // IMPORTANTE: Actualizar lastUserMessageTimestamp para mensajes salientes del usuario real
            let chatUpdateData = { 
                lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp(),
                lastUserMessageTimestamp: admin.firestore.FieldValue.serverTimestamp() // Esto es clave para el c√°lculo de presencia
            };
            
            await chatDocRef.set(chatUpdateData, { merge: true });
            console.log(`[Worker ${userId}][FIRESTORE] ‚úÖ Documento chat actualizado con lastUserMessageTimestamp`);
            
            // Verificar actualizaci√≥n del documento chat
            const updatedChatDoc = await chatDocRef.get();
            if (updatedChatDoc.exists) {
                console.log(`[Worker ${userId}][FIRESTORE] ‚úÖ Verificaci√≥n: Documento chat actualizado:`, JSON.stringify(updatedChatDoc.data()));
            }
        } catch (dbError) {
            console.error(`[Worker ${userId}][FIRESTORE] üî¥ ERROR guardando mensaje SALIENTE:`, dbError);
            sendErrorInfo(`Error guardando mensaje saliente: ${dbError.message}`);
        }
    }
});

client.on('message_revoke_everyone', async (after, before) => {
    console.log(`[Worker ${userId}][MESSAGE_REVOKE] Mensaje eliminado. FromMe: ${after.fromMe}, From: ${after.from}`);
});

client.on('message_ack', async (message, ack) => {
    // ACK: 1 = enviado, 2 = recibido, 3 = le√≠do, 4 = reproducido
    console.log(`[Worker ${userId}][MESSAGE_ACK] Confirmaci√≥n para mensaje. ACK: ${ack}, ID: ${message.id?.id}`);
});

// --- Procesamiento de Mensajes (adaptado del server.js original) ---
client.on('message', async (message) => {
  // <<< A√ëADIR ESTOS LOGS EXTENSIVOS AL INICIO DEL EVENTO >>>
  console.log(`\n[Worker ${userId}][MESSAGE EVENT] ====== NUEVO MENSAJE DETECTADO ======`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] Timestamp: ${new Date().toISOString()}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] Message ID: ${message.id?.id || 'unknown'}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] From: ${message.from || 'unknown'}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] To: ${message.to || 'unknown'}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] FromMe: ${message.fromMe}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] Body: "${message.body?.substring(0, 100)}..."`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] HasMedia: ${!!message.hasMedia}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] IsGroup: ${message.id?.remote?.endsWith('@g.us') || false}`);
  console.log(`[Worker ${userId}][MESSAGE EVENT] Raw Object: ${JSON.stringify(message, (key, value) => {
    // Eliminar propiedades circulares o muy grandes
    if (key === 'client' || key === '_data' || key === 'mediaData') return '[Object]';
    return value;
  }, 2).substring(0, 500)}...`);
  
  // <<< VERIFICAR SI PUPPETEER SIGUE FUNCIONANDO >>>
  try {
    if (!client.pupBrowser || !client.pupPage) {
      console.error(`[Worker ${userId}][ERROR CR√çTICO] Puppeteer browser/page no disponible en evento message. Browser: ${!!client.pupBrowser}, Page: ${!!client.pupPage}`);
      sendErrorInfo(`Puppeteer no disponible al procesar mensaje. Es posible que se haya desconectado.`);
    } else {
      console.log(`[Worker ${userId}][PUPPETEER STATUS] Browser: OK, Page: OK`);
    }
  } catch (puppeteerCheckError) {
    console.error(`[Worker ${userId}][ERROR CR√çTICO] Error verificando estado Puppeteer:`, puppeteerCheckError);
  }

  // <<< A√ëADIR LOGS TEMPRANO >>>
  console.log(`[Worker ${userId}][DEBUG] Message event fired. isFromMe: ${message.fromMe}, From: ${message.from}, To: ${message.to}, Body: "${message.body?.substring(0, 30)}..."`); 
  // <<< FIN DEL LOG TEMPRANO >>>

  // <<< INICIO: L√≥gica Modificada para Guardar TODOS los mensajes >>>
  const sender = message.from; 
  const recipient = message.to; 
  const isFromMe = message.fromMe;
  const isGroup = message.id.remote.endsWith('@g.us');

  // Ignorar grupos por ahora
  if (isGroup) return;

  // Determinar el ID del interlocutor para Firestore
  const chatPartnerId = isFromMe ? recipient : sender;
  
  console.log(`[Worker ${userId}][MSG ${isFromMe ? 'OUT' : 'IN'}] ${isFromMe ? 'To' : 'From'}: ${chatPartnerId}, Body: "${message.body?.substring(0, 50)}..."`);

  // Referencias de Firestore
  const chatDocRef = firestoreDbWorker.collection('users').doc(userId).collection('chats').doc(chatPartnerId);
  const messagesColRef = chatDocRef.collection('messages');

  // Guardar SIEMPRE el mensaje en Firestore
  try {
    console.log(`[Worker ${userId}][FIRESTORE] Guardando mensaje en: users/${userId}/chats/${chatPartnerId}/messages`);
    const messageData = {
        body: message.body,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
        isFromMe: isFromMe, 
        messageId: message.id.id,
        // Asegurar que se guarda la fuente del mensaje correctamente
        from: isFromMe ? `me (User REAL - ${userId})` : chatPartnerId,
        to: isFromMe ? chatPartnerId : `me (User REAL - ${userId})`,
        isAutoReply: isFromMe ? null : false,  // Expl√≠citamente null para mensajes del usuario real
        IS_GENUINE_USER: isFromMe ? true : false // NUEVO: Mensajes del usuario real son genuinos
    };
    
    console.log(`[Worker ${userId}][FIRESTORE] Datos a guardar:`, JSON.stringify(messageData));
    
    // Guardar el mensaje y obtener referencia
    const messageRef = await messagesColRef.add(messageData);
    console.log(`[Worker ${userId}][FIRESTORE] Mensaje guardado con ID: ${messageRef.id}`);
    
    // Verificar que se guard√≥ correctamente
    const savedMessage = await messageRef.get();
    if (savedMessage.exists) {
        console.log(`[Worker ${userId}][FIRESTORE] ‚úÖ Verificaci√≥n: Mensaje guardado correctamente`);
        console.log(`[Worker ${userId}][FIRESTORE] Datos guardados:`, JSON.stringify(savedMessage.data()));
    } else {
        console.error(`[Worker ${userId}][FIRESTORE] ‚ùå ERROR DE VERIFICACI√ìN: El mensaje no se guard√≥ correctamente`);
    }

    let chatUpdateData = { 
        lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp()
    }; 
    if (isFromMe) {
        chatUpdateData.lastUserMessageTimestamp = admin.firestore.FieldValue.serverTimestamp();
    }
    await chatDocRef.set(chatUpdateData, { merge: true });
    
    // Verificar actualizaci√≥n del documento chat
    const updatedChatDoc = await chatDocRef.get();
    console.log(`[Worker ${userId}][FIRESTORE] ‚úÖ Documento chat actualizado:`, JSON.stringify(updatedChatDoc.data()));

  } catch (dbError) {
      console.error(`[Worker ${userId}][FIRESTORE] üî¥ ERROR guardando mensaje para ${chatPartnerId}:`, dbError);
      sendErrorInfo(`Error guardando mensaje: ${dbError.message}`);
  }

  if (isFromMe) {
      console.log(`[Worker ${userId}] Mensaje es propio (fromMe=true). Terminando procesamiento.`);
      return; 
  }
  console.log(`[Worker ${userId}] Mensaje es de otro usuario. Continuando procesamiento...`);
  // <<< FIN: L√≥gica Modificada para Guardar TODOS los mensajes >>>

  // --- A√±adir log de isUserActiveInChat ---
  console.log(`[Worker ${userId}][PRESENCE CHECK] Verificando actividad para usuario ${userId} en chat ${sender}...`);
  const userIsActive = await isUserActiveInChat(userId, sender);
  console.log(`[Worker ${userId}][PRESENCE CHECK] Resultado: ${userIsActive ? 'ACTIVO' : 'INACTIVO'} (${userIsActive ? 'no responder autom√°ticamente' : 'responder autom√°ticamente'})`);

  try {
    // Si el usuario est√° inactivo, procesar respuestas autom√°ticas
    if (!userIsActive) {
      console.log(`[Worker ${userId}][AUTO-REPLY] Usuario INACTIVO. Procesando posibles respuestas autom√°ticas para: ${sender}`);

      // 1. Verificar si hay un flujo activado por el mensaje
      const matchedFlow = actionFlows.find(flow => {
        const messageTextLower = message.body.trim().toLowerCase();
        const triggerTextLower = flow.trigger?.trim().toLowerCase();
        return messageTextLower === triggerTextLower;
      });

      if (matchedFlow) {
        console.log(`[Worker ${userId}][AUTO-REPLY] Encontrado flujo coincidente: ${matchedFlow.name} (ID: ${matchedFlow.id}). Ejecutando...`);
        await executeActionFlow(message, matchedFlow);
        return; // Terminar aqu√≠ si se ejecut√≥ un flujo
      }

      // 2. Verificar si hay una regla simple que coincida
      const matchingSimpleRule = autoReplyRules.find(rule => {
        const messageTextInternal = message.body.trim().toLowerCase();
        const triggerText = rule.trigger.trim().toLowerCase();
        return messageTextInternal.includes(triggerText) || messageTextInternal === triggerText;
      });

      if (matchingSimpleRule) {
        console.log(`[Worker ${userId}][AUTO-REPLY] Encontrada regla simple coincidente. Respondiendo: "${matchingSimpleRule.response}"`);
            await randomDelay(); 
        await client.sendMessage(sender, matchingSimpleRule.response);
        
        // Guardar la respuesta autom√°tica en Firestore
            try {
                await messagesColRef.add({
            from: `me (Auto - ${userId})`,
                    to: sender,
            body: matchingSimpleRule.response,
                    timestamp: admin.firestore.FieldValue.serverTimestamp(),
            isFromMe: true,
            isAutoReply: true,
            IS_GENUINE_USER: false // NUEVO: Flag expl√≠cito para mensajes autom√°ticos
                });
                await chatDocRef.set({ lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
          console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta de regla simple guardada en Firestore.`);
            } catch (dbError) {
          console.error(`[Worker ${userId}][Firestore Error] Error guardando respuesta de regla simple:`, dbError);
        }
        return; // Terminar aqu√≠ si se ejecut√≥ una regla simple
      }

      // 3. Verificar si hay un starter de conversaci√≥n Gemini
        const matchedStarter = geminiConversationStarters.find(starter => {
            const messageTextInternal = message.body.trim().toLowerCase();
            const triggerText = starter.trigger.trim().toLowerCase();
            return messageTextInternal.includes(triggerText) || messageTextInternal === triggerText;
        });

        if (matchedStarter) {
        console.log(`[Worker ${userId}][AUTO-REPLY] Encontrado starter Gemini: "${matchedStarter.trigger}". Iniciando conversaci√≥n...`);
            const newActivePrompt = matchedStarter.prompt;
        
        // Guardar el prompt activo en Firestore
            try {
                await chatDocRef.set({ activeGeminiPrompt: newActivePrompt }, { merge: true });
          console.log(`[Worker ${userId}][AUTO-REPLY] Prompt Gemini activo guardado en Firestore: "${newActivePrompt}"`);
            } catch (dbError) {
          console.error(`[Worker ${userId}][Firestore Error] Error guardando prompt activo:`, dbError);
            }
            
        // Obtener contexto de mensajes recientes
            let starterContext = '';
            try {
                const recentMessagesSnap = await messagesColRef.orderBy('timestamp', 'desc').limit(10).get();
                const recentMessages = recentMessagesSnap.docs.reverse().map(doc => {
                    const msgData = doc.data();
                    return msgData.isFromMe ? `IA: ${msgData.body}` : `Usuario: ${msgData.body}`;
                });
                starterContext = recentMessages.join('\n');
            } catch (dbError) {
          console.error(`[Worker ${userId}][Firestore Error] Error obteniendo contexto para starter:`, dbError);
                starterContext = ' (Error cargando historial) ';
            }
        
        // Generar primera respuesta de Gemini
        const basePrompt = `Eres ${agentConfig.persona?.name || 'un asistente virtual'}. \nRol: ${agentConfig.persona?.role || 'Ayudar a los usuarios.'}\nTono: ${agentConfig.persona?.tone || 'amable'}. \nEstilo: ${agentConfig.persona?.style || 'claro'}. \nIdioma: ${agentConfig.persona?.language || 'es'}.\nDirectrices importantes:\n${(agentConfig.persona?.guidelines || []).map(g => `- ${g}`).join('\n') || '- Responde de forma concisa.'}\n---\n`;
            
            const firstResponsePrompt = `${basePrompt}${newActivePrompt}\n\n---\nHistorial Reciente:\n${starterContext}\n\n---\nPrimer Mensaje Recibido (que activ√≥ esto):\nUsuario: ${message.body}\n\n---\nTu Primera Respuesta (inicia la conversaci√≥n seg√∫n rol y directrices):`;
            
        console.log(`[Worker ${userId}][AUTO-REPLY] Enviando prompt inicial a Gemini...`);
        try {
            const result = await callGeminiWithRetry(firstResponsePrompt);
            const geminiResponse = await result;
            
            if (geminiResponse) {
            console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini generada: "${geminiResponse.substring(0, 50)}..."`);
                 await randomDelay(); 
                 await client.sendMessage(sender, geminiResponse);
            
            // Guardar respuesta en Firestore
                 try {
                     await messagesColRef.add({
                         from: `me (IA - ${userId})`,
                         to: sender,
                         body: geminiResponse,
                         timestamp: admin.firestore.FieldValue.serverTimestamp(),
                         isFromMe: true,
                         isAutoReply: true,
                         IS_GENUINE_USER: false // NUEVO: Flag expl√≠cito para mensajes autom√°ticos
                     });
                     await chatDocRef.set({ lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
              console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini guardada en Firestore.`);
                 } catch (dbError) {
              console.error(`[Worker ${userId}][Firestore Error] Error guardando respuesta Gemini:`, dbError);
            }
          } else {
            console.warn(`[Worker ${userId}][AUTO-REPLY] Gemini no gener√≥ respuesta para el prompt inicial.`);
                         await chatDocRef.update({ activeGeminiPrompt: null });
          }
        } catch (geminiError) {
          console.error(`[Worker ${userId}][AUTO-REPLY] Error generando respuesta Gemini:`, geminiError);
          await chatDocRef.update({ activeGeminiPrompt: null });
        }
        return; // Terminar aqu√≠ si se proces√≥ un starter
      }

      // 4. Verificar si hay una conversaci√≥n activa con Gemini
      try {
        const chatDataActive = await chatDocRef.get();
        const activeGeminiPrompt = chatDataActive.exists ? chatDataActive.data()?.activeGeminiPrompt : null;
        
        if (activeGeminiPrompt) {
          console.log(`[Worker ${userId}][AUTO-REPLY] Conversaci√≥n Gemini activa encontrada. Prompt: "${activeGeminiPrompt.substring(0, 50)}..."`);
          
          // Obtener contexto de mensajes recientes
          let conversationContext = '';
          try {
            const recentMessagesSnap = await messagesColRef.orderBy('timestamp', 'desc').limit(10).get();
            const recentMessages = recentMessagesSnap.docs.reverse().map(doc => {
              const msgData = doc.data();
              return msgData.isFromMe ? `IA: ${msgData.body}` : `Usuario: ${msgData.body}`;
            });
            conversationContext = recentMessages.join('\n');
          } catch (dbError) {
            console.error(`[Worker ${userId}][Firestore Error] Error obteniendo contexto de conversaci√≥n:`, dbError);
            conversationContext = ' (Error cargando historial) ';
          }
          
          // Generar respuesta de continuaci√≥n
          const basePrompt = `Eres ${agentConfig.persona?.name || 'un asistente virtual'}. \nRol: ${agentConfig.persona?.role || 'Ayudar a los usuarios.'}\nTono: ${agentConfig.persona?.tone || 'amable'}. \nEstilo: ${agentConfig.persona?.style || 'claro'}. \nIdioma: ${agentConfig.persona?.language || 'es'}.\nDirectrices importantes:\n${(agentConfig.persona?.guidelines || []).map(g => `- ${g}`).join('\n') || '- Responde de forma concisa.'}\n---\n`;
          
          const conversationPrompt = `${basePrompt}${activeGeminiPrompt}\n\n---\nHistorial Reciente:\n${conversationContext}\n\n---\nMensaje Actual:\nUsuario: ${message.body}\n\n---\nTu Respuesta (sigue la conversaci√≥n y directrices):`;
          
          console.log(`[Worker ${userId}][AUTO-REPLY] Enviando prompt de continuaci√≥n a Gemini...`);
          try {
            const result = await callGeminiWithRetry(conversationPrompt);
            const geminiResponse = await result;
            
            if (geminiResponse) {
              console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini generada: "${geminiResponse.substring(0, 50)}..."`);
        await randomDelay(); 
              await client.sendMessage(sender, geminiResponse);
              
              // Guardar respuesta en Firestore
        try {
            await messagesColRef.add({
                  from: `me (IA - ${userId})`,
                to: sender,
                  body: geminiResponse,
                timestamp: admin.firestore.FieldValue.serverTimestamp(),
                  isFromMe: true,
                  isAutoReply: true,
                  IS_GENUINE_USER: false // NUEVO: Flag expl√≠cito para mensajes autom√°ticos
            });
            await chatDocRef.set({ lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
                console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini guardada en Firestore.`);
        } catch (dbError) {
                console.error(`[Worker ${userId}][Firestore Error] Error guardando respuesta Gemini:`, dbError);
              }
              
              // Verificar si hay keyword de finalizaci√≥n
              const lowerBody = message.body.toLowerCase().trim();
              const endKeywords = ['gracias', 'chau', 'nos vemos', 'adios', 'hasta luego'];
              if (endKeywords.some(keyword => lowerBody.includes(keyword))) {
                console.log(`[Worker ${userId}][AUTO-REPLY] Detectada palabra clave de finalizaci√≥n. Cerrando conversaci√≥n.`);
                await chatDocRef.update({ activeGeminiPrompt: null });
              }
    } else {
              console.warn(`[Worker ${userId}][AUTO-REPLY] Gemini no gener√≥ respuesta para la conversaci√≥n.`);
            }
          } catch (geminiError) {
            console.error(`[Worker ${userId}][AUTO-REPLY] Error generando respuesta Gemini:`, geminiError);
          }
          return; // Terminar aqu√≠ si se continu√≥ una conversaci√≥n
        }
      } catch (chatError) {
        console.error(`[Worker ${userId}][AUTO-REPLY] Error verificando conversaci√≥n activa:`, chatError);
      }

      // 5. Si no hay reglas, starters ni conversaci√≥n activa, generar respuesta por defecto
      console.log(`[Worker ${userId}][AUTO-REPLY] No se encontraron reglas ni conversaciones activas. Generando respuesta por defecto...`);
      
      // Obtener contexto de mensajes recientes
            let defaultContext = '';
            try {
                const recentMessagesSnap = await messagesColRef.orderBy('timestamp', 'desc').limit(10).get();
                const recentMessages = recentMessagesSnap.docs.reverse().map(doc => {
                    const msgData = doc.data();
                    return msgData.isFromMe ? `IA: ${msgData.body}` : `Usuario: ${msgData.body}`;
                });
                defaultContext = recentMessages.join('\n');
            } catch (dbError) {
        console.error(`[Worker ${userId}][Firestore Error] Error obteniendo contexto para respuesta default:`, dbError);
                defaultContext = ' (Error cargando historial) ';
            }
      
      // Generar respuesta por defecto
      const basePrompt = `Eres ${agentConfig.persona?.name || 'un asistente virtual'}. \nRol: ${agentConfig.persona?.role || 'Ayudar a los usuarios.'}\nTono: ${agentConfig.persona?.tone || 'amable'}. \nEstilo: ${agentConfig.persona?.style || 'claro'}. \nIdioma: ${agentConfig.persona?.language || 'es'}.\nDirectrices importantes:\n${(agentConfig.persona?.guidelines || []).map(g => `- ${g}`).join('\n') || '- Responde de forma concisa.'}\n---\n`;
            
            const defaultAiPrompt = `${basePrompt}
---
Historial Reciente:
${defaultContext}

---
Mensaje Actual del Usuario:
Usuario: ${message.body}

---
Tu Respuesta (siguiendo rol, tono, directrices y contexto):`;

      console.log(`[Worker ${userId}][AUTO-REPLY] Enviando prompt default a Gemini...`);
            try {
                const result = await callGeminiWithRetry(defaultAiPrompt);
                const geminiResponse = await result;

                if (geminiResponse) {
          console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini default generada: "${geminiResponse.substring(0, 50)}..."`);
                    await randomDelay(); 
                    await client.sendMessage(sender, geminiResponse);
          
          // Guardar respuesta en Firestore
                    try {
                        await messagesColRef.add({
                            from: `me (IA - ${userId})`,
                            to: sender,
                            body: geminiResponse,
                            timestamp: admin.firestore.FieldValue.serverTimestamp(),
                            isFromMe: true,
                            isAutoReply: true,
                            IS_GENUINE_USER: false // NUEVO: Flag expl√≠cito para mensajes autom√°ticos
                        });
                        await chatDocRef.set({ lastMessageTimestamp: admin.firestore.FieldValue.serverTimestamp() }, { merge: true });
            console.log(`[Worker ${userId}][AUTO-REPLY] Respuesta Gemini default guardada en Firestore.`);
                    } catch (dbError) {
            console.error(`[Worker ${userId}][Firestore Error] Error guardando respuesta Gemini default:`, dbError);
                    }
                } else {
          console.warn(`[Worker ${userId}][AUTO-REPLY] Gemini no gener√≥ respuesta default.`);
                }
            } catch (geminiError) {
        console.error(`[Worker ${userId}][AUTO-REPLY] Error generando respuesta Gemini default:`, geminiError);
      }
    } else {
      console.log(`[Worker ${userId}][AUTO-REPLY] Usuario ACTIVO. No se enviar√°n respuestas autom√°ticas.`);
    }
  } catch (presenceError) {
    console.error(`[Worker ${userId}][AUTO-REPLY] Error en flujo de respuesta autom√°tica:`, presenceError);
    sendErrorInfo(`Error en flujo de respuesta autom√°tica: ${presenceError.message}`);
  }

  // Resto del c√≥digo del manejador...
  // ... existing code ...
});

// === MANEJO DE COMANDOS IPC DEL MASTER ===
let isShuttingDown = false;

process.on('message', (message) => {
    // --- Log A√ëADIDO para depurar recepci√≥n --- 
    console.log(`[Worker ${userId}] ===> process.on('message') RECIBIDO:`, JSON.stringify(message)); 

    if (!message || !message.type) {
        console.warn(`[Worker ${userId}] Mensaje IPC inv√°lido recibido o sin tipo.`);
        return;
    }

    console.log(`[IPC Worker ${userId}] Comando recibido del Master (Tipo: ${message.type}):`, message);

    switch (message.type) {
        case 'COMMAND':
            handleCommand(message.command, message.payload);
            break;
            case 'SWITCH_AGENT':
                console.log(`[Worker ${userId}] Recibido comando para cambiar agente activo...`, message.payload);
                const switchPayload = message.payload;
                currentAgentId = switchPayload?.agentId || null;
                console.log(`[Worker ${userId}] ID de agente activo establecido a: ${currentAgentId || 'Ninguno (default)'}.`);
            
                if (switchPayload?.agentConfig) {
                    agentConfig = switchPayload.agentConfig;
                    console.log(`   -> Configuraci√≥n de agente actualizada desde payload SWITCH_AGENT para: ${agentConfig.persona?.name || currentAgentId}`);
                } else if (!currentAgentId) {
                    agentConfig = { ...DEFAULT_AGENT_CONFIG }; // Volver a default si ID es null y no vino config
                    console.log(`   -> Usando configuraci√≥n de agente por defecto (ID es null).`);
                } else {
                    // No vino config en el payload, pero hay un agentId. Se usar√° la config que ya tenga cargada 
                    // (posiblemente de INITIAL_CONFIG o un RELOAD anterior). Loguear advertencia.
                    console.warn(`   -> SWITCH_AGENT recibido para ${currentAgentId} SIN payload de config. Se usar√° la config en memoria si existe.`);
                    // En este punto, agentConfig NO se modifica.
                }
                break;
        case 'INITIAL_CONFIG': // <<< ADDED: Manejar configuraci√≥n inicial >>>
            console.log(`[Worker ${userId}] Recibida configuraci√≥n inicial del Master.`);
            const configPayload = message.payload;
            if (configPayload) {
                agentConfig = configPayload.agentConfig || { ...DEFAULT_AGENT_CONFIG };
                currentAgentId = agentConfig.id || null;
                
                autoReplyRules = Array.isArray(configPayload.rules) ? configPayload.rules : [];
                geminiConversationStarters = Array.isArray(configPayload.starters) ? configPayload.starters : [];
                actionFlows = Array.isArray(configPayload.flows) ? configPayload.flows : [];
                
                console.log(`   -> Agent Config Loaded: ${agentConfig.persona?.name || (currentAgentId ? `ID ${currentAgentId}` : 'Default')}`);
                console.log(`   -> Rules Loaded: ${autoReplyRules.length}`);
                console.log(`   -> Starters Loaded: ${geminiConversationStarters.length}`);
                console.log(`   -> Flows Loaded: ${actionFlows.length}`);
            } else {
                console.warn(`[Worker ${userId}] Mensaje INITIAL_CONFIG recibido SIN payload. Usando defaults.`);
                agentConfig = { ...DEFAULT_AGENT_CONFIG };
                autoReplyRules = [];
                geminiConversationStarters = [];
                actionFlows = [];
                currentAgentId = null;
            }
            break;
        case 'RELOAD_FLOWS':
            console.log(`[Worker ${userId}] Recibido comando para recargar flujos de acci√≥n...`);
            if (payload && Array.isArray(payload.flows)) { 
                actionFlows = payload.flows;
                console.log(`   -> Flujos de acci√≥n actualizados desde payload. Total: ${actionFlows.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_FLOWS recibido sin payload de flujos v√°lido. No se puede actualizar.`);
            }
            break;
        case 'RELOAD_RULES': // <<< ADDED
            console.log(`[Worker ${userId}] Recibido comando RELOAD_RULES.`);
            if (payload && Array.isArray(payload.rules)) {
                autoReplyRules = payload.rules;
                console.log(`   -> Reglas actualizadas desde payload. Total: ${autoReplyRules.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_RULES recibido sin payload de reglas v√°lido. No se puede actualizar.`);
            }
            break;
        case 'RELOAD_STARTERS': // <<< ADDED
            console.log(`[Worker ${userId}] Recibido comando RELOAD_STARTERS.`);
            if (payload && Array.isArray(payload.starters)) {
                geminiConversationStarters = payload.starters;
                console.log(`   -> Starters actualizados desde payload. Total: ${geminiConversationStarters.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_STARTERS recibido sin payload de starters v√°lido. No se puede actualizar.`);
            }
            break;
        case 'RELOAD_AGENT_CONFIG': // <<< ADDED
             console.log(`[Worker ${userId}] Recibido comando RELOAD_AGENT_CONFIG.`);
            if (payload && payload.agentConfig && payload.agentConfig.id === currentAgentId) {
                agentConfig = payload.agentConfig;
                console.log(`   -> Configuraci√≥n para agente activo (${currentAgentId}) actualizada desde payload.`);
            } else if (payload && payload.agentConfig && payload.agentConfig.id !== currentAgentId){
                 console.warn(`   -> Recibido RELOAD_AGENT_CONFIG para agente ${payload.agentConfig.id}, pero el agente activo es ${currentAgentId}. Configuraci√≥n no aplicada.`);
             } else if (!payload || !payload.agentConfig) {
                console.warn(`   -> Comando RELOAD_AGENT_CONFIG recibido sin payload de config v√°lido. No se puede actualizar.`);
            }
            break;
         // TODO: A√±adir case para 'RELOAD_CONFIG' (para otras configs)
         // ...
        default:
            console.warn(`[IPC Worker ${userId}] Tipo de mensaje no reconocido: ${message.type}`);
    }
});

function handleCommand(command, payload) {
    console.log(`[Worker ${userId}] Procesando comando: ${command}`);
    switch (command) {
        case 'SHUTDOWN':
            console.log(`[Worker ${userId}] ===> ENTRANDO al case SHUTDOWN`); // Log inicio case
            if (!isShuttingDown) {
                isShuttingDown = true;
                console.log(`[Worker ${userId}] Iniciando cierre ordenado... (isShuttingDown = true)`);
                if (client) {
                     console.log(`[Worker ${userId}] ===> INTENTANDO llamar a client.destroy()...`); // Log antes destroy
                     client.destroy() // Intenta cerrar la sesi√≥n de WhatsApp limpiamente
                        .then(() => {
                            console.log(`[Worker ${userId}] ===> client.destroy() COMPLETADO (then).`); // Log en then
                            console.log(`[Worker ${userId}] Cliente WhatsApp destruido. Saliendo con process.exit(0)...`);
                            process.exit(0); // Salir despu√©s de destruir
                        })
                        .catch(err => {
                            console.error(`[Worker ${userId}] ===> ERROR CAPTURADO en .catch() de client.destroy():`, err); // Log en catch
                            console.error(`[Worker ${userId}] Saliendo con process.exit(1) debido a error en destroy...`);
                            process.exit(1); // Salir con error si falla
                        });
                     console.log(`[Worker ${userId}] ===> C√≥digo DESPU√âS de la llamada a client.destroy() alcanzado.`); // Log despu√©s de llamada (no espera)
                } else {
                    console.log(`[Worker ${userId}] Cliente no inicializado, saliendo directamente con process.exit(0).`);
                    process.exit(0);
                }
                 // Poner un temporizador por si destroy() se cuelga
                 console.log(`[Worker ${userId}] ===> Estableciendo setTimeout de 10 segundos para forzar salida.`);
                 setTimeout(() => {
                    console.warn(`[Worker ${userId}] ===> TIMEOUT de cierre alcanzado! Forzando salida con process.exit(1).`); // Log en timeout
                    process.exit(1);
                 }, 10000); // 10 segundos de gracia
            } else {
                console.log(`[Worker ${userId}] ===> Comando SHUTDOWN recibido pero ya estaba en proceso de cierre (isShuttingDown=true).`);
            }
            break;
        case 'RELOAD_FLOWS':
            console.log(`[Worker ${userId}] Recibido comando para recargar flujos de acci√≥n...`);
            if (payload && Array.isArray(payload.flows)) { 
                actionFlows = payload.flows;
                console.log(`   -> Flujos de acci√≥n actualizados desde payload. Total: ${actionFlows.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_FLOWS recibido sin payload de flujos v√°lido. No se puede actualizar.`);
            }
            break;
        case 'SWITCH_AGENT':
            console.log(`[Worker ${userId}] Procesando comando SWITCH_AGENT...`, payload);
            const newAgentId = payload?.agentId || null;
            currentAgentId = newAgentId;
            console.log(`[Worker ${userId}] ID de agente activo establecido a: ${currentAgentId || 'Ninguno (default)'}.`);
            if (!currentAgentId) {
                console.log(`   -> Usando configuraci√≥n de agente por defecto (ID es null).`);
                agentConfig = { ...DEFAULT_AGENT_CONFIG };
            } else {
                 console.log(`   -> Se espera que la configuraci√≥n para el agente ${currentAgentId} se reciba por separado si es necesario.`);
            }
            break;
        case 'RELOAD_RULES': // <<< ADDED
            console.log(`[Worker ${userId}] Recibido comando RELOAD_RULES.`);
            if (payload && Array.isArray(payload.rules)) {
                autoReplyRules = payload.rules;
                console.log(`   -> Reglas actualizadas desde payload. Total: ${autoReplyRules.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_RULES recibido sin payload de reglas v√°lido. No se puede actualizar.`);
            }
            break;
        case 'RELOAD_STARTERS': // <<< ADDED
            console.log(`[Worker ${userId}] Recibido comando RELOAD_STARTERS.`);
            if (payload && Array.isArray(payload.starters)) {
                geminiConversationStarters = payload.starters;
                console.log(`   -> Starters actualizados desde payload. Total: ${geminiConversationStarters.length}`);
            } else {
                console.warn(`   -> Comando RELOAD_STARTERS recibido sin payload de starters v√°lido. No se puede actualizar.`);
            }
            break;
        case 'RELOAD_AGENT_CONFIG': // <<< ADDED
             console.log(`[Worker ${userId}] Recibido comando RELOAD_AGENT_CONFIG.`);
            if (payload && payload.agentConfig && payload.agentConfig.id === currentAgentId) {
                agentConfig = payload.agentConfig;
                console.log(`   -> Configuraci√≥n para agente activo (${currentAgentId}) actualizada desde payload.`);
            } else if (payload && payload.agentConfig && payload.agentConfig.id !== currentAgentId){
                 console.warn(`   -> Recibido RELOAD_AGENT_CONFIG para agente ${payload.agentConfig.id}, pero el agente activo es ${currentAgentId}. Configuraci√≥n no aplicada.`);
             } else if (!payload || !payload.agentConfig) {
                console.warn(`   -> Comando RELOAD_AGENT_CONFIG recibido sin payload de config v√°lido. No se puede actualizar.`);
            }
            break;
         // TODO: A√±adir case para 'RELOAD_CONFIG' (para otras configs)
         // ...
        default:
            console.warn(`[IPC Worker ${userId}] Tipo de mensaje no reconocido: ${command}`);
    }
}

// A√±adir manejadores de excepciones no capturadas al final del archivo
process.on('uncaughtException', (error) => {
    console.error(`[Worker ${userId}][CRITICAL] UNCAUGHT EXCEPTION:`, error);
    sendErrorInfo(`Excepci√≥n no capturada: ${error.message}\n${error.stack}`);
    sendStatusUpdate('error', `Error cr√≠tico no capturado: ${error.message}`);
    // No cerramos el proceso aqu√≠ para permitir debugging
});

process.on('unhandledRejection', (reason, promise) => {
    console.error(`[Worker ${userId}][CRITICAL] UNHANDLED REJECTION:`, reason);
    sendErrorInfo(`Promesa rechazada no manejada: ${reason}`);
    sendStatusUpdate('error', `Promesa rechazada no manejada: ${reason}`);
    // No cerramos el proceso aqu√≠ para permitir debugging
});

// <<< REEMPLAZADO: L√≥gica de Presencia Basada en Firestore >>>
async function isUserActiveInChat(userId, senderId) {
    console.log(`\n[Worker ${userId}][PRESENCE] ====== VERIFICANDO PRESENCIA - NUEVA L√ìGICA ESTRICTA ======`);
    console.log(`[Worker ${userId}][PRESENCE] Par√°metros: userId=${userId}, senderId=${senderId}`);
    
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    console.log(`[Worker ${userId}][PRESENCE] Timestamp l√≠mite: ${fiveMinutesAgo.toISOString()} (hace 5 minutos)`);
    
    const chatDocRef = firestoreDbWorker.collection('users').doc(userId).collection('chats').doc(senderId);
    const messagesRef = chatDocRef.collection('messages');
    
    try {
        // 1. Verificar si hay lastUserMessageTimestamp en el chat (m√©todo r√°pido)
        const chatDoc = await chatDocRef.get();
        if (!chatDoc.exists) {
            console.log(`[Worker ${userId}][PRESENCE] ‚ùå El documento de chat no existe. Usuario considerado INACTIVO.`);
            return false;
        }
        
        if (chatDoc.data().lastUserMessageTimestamp) {
            const lastTimestamp = chatDoc.data().lastUserMessageTimestamp.toDate();
            const isActive = lastTimestamp > fiveMinutesAgo;
            console.log(`[Worker ${userId}][PRESENCE] Usando lastUserMessageTimestamp del chat: ${lastTimestamp.toISOString()}`);
            console.log(`[Worker ${userId}][PRESENCE] Resultado: Usuario ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
            return isActive;
        }
        
        // 2. Buscar mensajes con el nuevo flag expl√≠cito IS_GENUINE_USER
        console.log(`[Worker ${userId}][PRESENCE] Buscando mensajes con IS_GENUINE_USER=true`);
        let genuineMessages;
        try {
            genuineMessages = await messagesRef
                .where('IS_GENUINE_USER', '==', true)
                .orderBy('timestamp', 'desc')
                .limit(1)
                .get();
                
            console.log(`[Worker ${userId}][PRESENCE] Encontrados ${genuineMessages.size} mensajes genuinos del usuario`);
            
            if (!genuineMessages.empty) {
                const lastGenuineMsg = genuineMessages.docs[0].data();
                const timestamp = lastGenuineMsg.timestamp?.toDate();
                
                if (timestamp) {
                    const isActive = timestamp > fiveMinutesAgo;
                    console.log(`[Worker ${userId}][PRESENCE] √öltimo mensaje genuino: ${timestamp.toISOString()}`);
                    console.log(`[Worker ${userId}][PRESENCE] Resultado: Usuario ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
                    
                    // Actualizar lastUserMessageTimestamp para referencia futura
                    await chatDocRef.set({
                        lastUserMessageTimestamp: lastGenuineMsg.timestamp
                    }, { merge: true });
                    
                    return isActive;
                }
            }
            
            // 3. Si no hay mensajes con IS_GENUINE_USER, buscar la manera antigua
            console.log(`[Worker ${userId}][PRESENCE] No se encontraron mensajes con IS_GENUINE_USER, buscando con m√©todo alternativo`);
            const oldMethodQuery = await messagesRef
                .where('isFromMe', '==', true)
                .where('isAutoReply', '==', null)
                .orderBy('timestamp', 'desc')
                .limit(5)
                .get();
                
            if (!oldMethodQuery.empty) {
                // Filtrar manualmente para mayor seguridad
                const filteredDocs = oldMethodQuery.docs.filter(doc => {
                    const data = doc.data();
                    return data.isFromMe === true && 
                           data.isAutoReply === null &&
                           !data.from?.includes('Auto') && 
                           !data.from?.includes('IA') && 
                           !data.from?.includes('Flow');
                });
                
                if (filteredDocs.length > 0) {
                    const lastMessage = filteredDocs[0].data();
                    const timestamp = lastMessage.timestamp?.toDate();
                    
                    if (timestamp) {
                        const isActive = timestamp > fiveMinutesAgo;
                        console.log(`[Worker ${userId}][PRESENCE] √öltimo mensaje (m√©todo antiguo): ${timestamp.toISOString()}`);
                        console.log(`[Worker ${userId}][PRESENCE] Resultado: Usuario ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
                        return isActive;
                    }
                }
            }
            
            // Si llegamos aqu√≠, no hemos encontrado mensajes genuinos del usuario
            console.log(`[Worker ${userId}][PRESENCE] No se encontraron mensajes genuinos del usuario. INACTIVO.`);
            return false;
            
        } catch (queryError) {
            console.error(`[Worker ${userId}][PRESENCE] Error en consulta: ${queryError.message}`);
            
            // M√©todo de √∫ltimo recurso: buscar por texto en los campos 'from'
            const lastResortQuery = await messagesRef
                .orderBy('timestamp', 'desc')
                .limit(20)
                .get();
                
            if (!lastResortQuery.empty) {
                const realUserMsgs = lastResortQuery.docs.filter(doc => {
                    const data = doc.data();
                    return data.from?.includes('User REAL');
                });
                
                if (realUserMsgs.length > 0) {
                    const lastMessage = realUserMsgs[0].data();
                    const timestamp = lastMessage.timestamp?.toDate();
                    
                    if (timestamp) {
                        const isActive = timestamp > fiveMinutesAgo;
                        console.log(`[Worker ${userId}][PRESENCE] √öltimo mensaje (√∫ltimo recurso): ${timestamp.toISOString()}`);
                        console.log(`[Worker ${userId}][PRESENCE] Resultado: Usuario ${isActive ? 'ACTIVO' : 'INACTIVO'}`);
                        return isActive;
                    }
                }
            }
            
            console.log(`[Worker ${userId}][PRESENCE] No se pudo determinar actividad. INACTIVO.`);
            return false;
        }
        
    } catch (error) {
        console.error(`[Worker ${userId}][PRESENCE] Error cr√≠tico: ${error.message}`);
        console.log(`[Worker ${userId}][PRESENCE] Por precauci√≥n, considerando al usuario ACTIVO.`);
        return true; // Por seguridad, si hay error consideramos que est√° activo
    }
}
// <<< FIN: L√≥gica de Presencia Basada en Firestore >>>

